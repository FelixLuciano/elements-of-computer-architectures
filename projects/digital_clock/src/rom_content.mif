DEPTH = 512;
WIDTH = 16;
ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;

CONTENT BEGIN
      0: 0100100000000000;  -- ldi$0 [MAIN] "Carrega 0 no %ax"
      1: 0001000100100000;  -- sta@288 "Descarrega 0 do %ax no HEX0, inicializando display"
      2: 0001000100100001;  -- sta@289 "Descarrega 0 do %ax no HEX1, inicializando display"
      3: 0001000100100010;  -- sta@290 "Descarrega 0 do %ax no HEX2, inicializando display"
      4: 0001000100100011;  -- sta@291 "Descarrega 0 do %ax no HEX3, inicializando display"
      5: 0001000100100100;  -- sta@292 "Descarrega 0 do %ax no HEX4, inicializando display"
      6: 0001000100100101;  -- sta@293 "Descarrega 0 do %ax no HEX5, inicializando display"
      7: 0100100000010010;  -- ldi$18 "Carrega 18 no %ax"
      8: 0001000110000000;  -- sta@384 "Descarrega 10 do %ax no TC0, definindo base de contagem para 2^18"
      9: 0000000000000000;  -- nop@0 [LOOP] "Janela para atuação das interrupções"
     10: 1000000000001001;  -- jmp.9 "Desvia de volta para LOOP"
     11: 1101111000000000;  -- ldaind$0 %dx [INC_DX] "Carrega valor do digito na memória"
     12: 0101011000000001;  -- addi$1 %dx "Incrementa em 1 o valor no %dx"
     13: 0100011000001000;  -- cle@8 %dx "Verifica se o valor é menor ou igual ao limite em INC1"
     14: 1001100000010000;  -- jle.16 "Se for menor ou igual ao limite, pula para INC_DX__UPDATE"
     15: 0100111000000000;  -- ldi$0 %dx "Se não, zera valor do dígito"
     16: 1110011000000000;  -- staind$0 %dx [INC_DX__UPDATE] "Atualiza valor na memória"
     17: 1100000000000000;  -- ret.0 "Retorna subrotina INC_DX"
     18: 1101111000000000;  -- ldaind$0 %dx [DEC_DX] "Carrega valor do digito na memória"
     19: 0101111000000001;  -- subi$1 %dx "Decrementa em 1 o valor no %dx"
     20: 0111111000000000;  -- cgei$0 %dx "Verifica se o valor é maior ou igual a 0"
     21: 1011000000010111;  -- jge.23 "Se for, pula para DEC_DX__UPDATE"
     22: 0000111000001001;  -- lda@9 %dx "Se não, define para o valor limite em @DEC1"
     23: 1110011000000000;  -- staind$0 %dx [DEC_DX__UPDATE] "Atualiza valor na memória"
     24: 1100000000000000;  -- ret.0 "Retorna subrotina DECREMENT_DIGIT"
     25: 1101000000000010;  -- ldaddr@2 [INC_D0] "Define ponteiro para dig0"
     26: 0100111000001001;  -- ldi$9 %dx "Carrega 9 no %dx"
     27: 0001011000001000;  -- sta@8 %dx "Guarda na 9 do %dx no endereço do argumeto 1 de INC_DX"
     28: 1011100000001011;  -- jsr.11 "Chama subrotina INC_DX"
     29: 0001011100100000;  -- sta@288 %dx "Atualiza o HEX0 com o retorno subrotina"
     30: 1001100001000000;  -- jle.64 "Se não fez overflow, desvia para INC_D0__RET"
     31: 1101000000000011;  -- ldaddr@3 [INC_D1] "Define ponteiro para dig1"
     32: 0100111000000101;  -- ldi$5 %dx "Carrega 5 no %dx"
     33: 0001011000001000;  -- sta@8 %dx "Guarda na 5 do %dx no endereço do argumeto 1 de INC_DX"
     34: 1011100000001011;  -- jsr.11 "Chama subrotina INC_DX"
     35: 0001011100100001;  -- sta@289 %dx "Atualiza o HEX1 com o retorno subrotina"
     36: 1001100001000000;  -- jle.64 "Se não fez overflow, desvia para INC_D0__RET"
     37: 1101000000000100;  -- ldaddr@4 [INC_D2] "Define ponteiro para dig2"
     38: 0100111000001001;  -- ldi$9 %dx "Carrega 9 no %dx"
     39: 0001011000001000;  -- sta@8 %dx "Guarda na 9 do %dx no endereço do argumeto 1 de INC_DX"
     40: 1011100000001011;  -- jsr.11 "Chama subrotina INC_DX"
     41: 0001011100100010;  -- sta@290 %dx "Atualiza o HEX2 com o retorno subrotina"
     42: 1001100001000000;  -- jle.64 "Se não fez overflow, desvia para INC_D0__RET"
     43: 1101000000000101;  -- ldaddr@5 [INC_D3] "Define ponteiro para dig3"
     44: 0100111000000101;  -- ldi$5 %dx "Carrega 5 no %dx"
     45: 0001011000001000;  -- sta@8 %dx "Guarda na 5 do %dx no endereço do argumeto 1 de INC_DX"
     46: 1011100000001011;  -- jsr.11 "Chama subrotina INC_DX"
     47: 0001011100100011;  -- sta@291 %dx "Atualiza o HEX3 com o retorno subrotina"
     48: 1001100001000000;  -- jle.64 "Se não fez overflow, desvia para INC_D0__RET"
     49: 1101000000000110;  -- ldaddr@6 [INC_D4] "Define ponteiro para dig4"
     50: 0000111000000111;  -- lda@7 %dx "Carrega valor da dezena de hora no %dx"
     51: 0111111000000001;  -- cgei$1 %dx "Compara se o valor é maior ou igual a 1"
     52: 0100111000000011;  -- ldi$3 %dx "Carrega 3 no %dx"
     53: 1011000000110111;  -- jge.55 "Caso seja maior ou igual, Desvia para INC_D4__SET_BASE"
     54: 0100111000001001;  -- ldi$9 %dx "Se não, carrega 9 no %dx"
     55: 0001011000001000;  -- sta@8 %dx [INC_D4__SET_BASE] "Guarda a base de contagem do %dx no endereço do argumeto 1 de INC_DX"
     56: 1011100000001011;  -- jsr.11 "Chama subrotina INC_DX"
     57: 0001011100100100;  -- sta@292 %dx "Atualiza o HEX4 com o retorno subrotina"
     58: 1001100001000000;  -- jle.64 "Se não fez overflow, desvia para INC_D0__RET"
     59: 1101000000000111;  -- ldaddr@7 [INC_D5] "Define ponteiro para dig5"
     60: 0100111000000010;  -- ldi$2 %dx "Carrega 2 no %dx"
     61: 0001011000001000;  -- sta@8 %dx "Guarda na 2 no endereço do argumeto 1 de INC_DX"
     62: 1011100000001011;  -- jsr.11 "Chama subrotina INC_DX"
     63: 0001011100100101;  -- sta@293 %dx "Atualiza o HEX5 com o retorno subrotina"
     64: 1100000000000000;  -- ret.0 [INC_D0__RET] "Retorna subrotina INC_D0"
     65: 1101000000000010;  -- ldaddr@2 [DEC_D0] "Define ponteiro para dig0"
     66: 0100111000001001;  -- ldi$9 %dx "Carrega 9 no %dx"
     67: 0001011000001001;  -- sta@9 %dx "Guarda na 9 do %dx no endereço do argumeto 1 de DEC_DX"
     68: 1011100000010010;  -- jsr.18 "Chama subrotina DEC_DX"
     69: 0001011100100000;  -- sta@288 %dx "Atualiza o HEX0 com o retorno subrotina"
     70: 1011000001101000;  -- jge.104 "Se não fez underflow, desvia para DEC_D0__RET"
     71: 1101000000000011;  -- ldaddr@3 [DEC_D1] "Define ponteiro para dig1"
     72: 0100111000000101;  -- ldi$5 %dx "Carrega 5 no %dx"
     73: 0001011000001001;  -- sta@9 %dx "Guarda na 5 do %dx no endereço do argumeto 1 de DEC_DX"
     74: 1011100000010010;  -- jsr.18 "Chama subrotina DEC_DX"
     75: 0001011100100001;  -- sta@289 %dx "Atualiza o HEX1 com o retorno subrotina"
     76: 1011000001101000;  -- jge.104 "Se não fez underflow, desvia para DEC_D0__RET"
     77: 1101000000000100;  -- ldaddr@4 [DEC_D2] "Define ponteiro para dig2"
     78: 0100111000001001;  -- ldi$9 %dx "Carrega 9 no %dx"
     79: 0001011000001001;  -- sta@9 %dx "Guarda na 9 do %dx no endereço do argumeto 1 de DEC_DX"
     80: 1011100000010010;  -- jsr.18 "Chama subrotina DEC_DX"
     81: 0001011100100010;  -- sta@290 %dx "Atualiza o HEX2 com o retorno subrotina"
     82: 1011000001101000;  -- jge.104 "Se não fez underflow, desvia para DEC_D0__RET"
     83: 1101000000000101;  -- ldaddr@5 [DEC_D3] "Define ponteiro para dig3"
     84: 0100111000000101;  -- ldi$5 %dx "Carrega 9 no %dx"
     85: 0001011000001001;  -- sta@9 %dx "Guarda na 5 do %dx no endereço do argumeto 1 de DEC_DX"
     86: 1011100000010010;  -- jsr.18 "Chama subrotina DEC_DX"
     87: 0001011100100011;  -- sta@291 %dx "Atualiza o HEX3 com o retorno subrotina"
     88: 1011000001101000;  -- jge.104 "Se não fez underflow, desvia para DEC_D0__RET"
     89: 1101000000000110;  -- ldaddr@6 [DEC_D4] "Define ponteiro para dig4"
     90: 0000111000000111;  -- lda@7 %dx "Carrega valor da dezena de hora no %dx"
     91: 0110111000000000;  -- ceqi$0 %dx "Compara se o valor é igual a 0"
     92: 0100111000000011;  -- ldi$3 %dx "Carrega 3 no %dx"
     93: 1000100001011111;  -- jeq.95 "Caso seja igual, Desvia para DEC_D4__SET_BASE"
     94: 0100111000001001;  -- ldi$9 %dx "Se não, carrega 9 no %dx"
     95: 0001011000001001;  -- sta@9 %dx [DEC_D4__SET_BASE] "Guarda na 9 no endereço do argumeto 1 de DEC_DX"
     96: 1011100000010010;  -- jsr.18 "Chama subrotina DEC_DX"
     97: 0001011100100100;  -- sta@292 %dx "Atualiza o HEX4 com o retorno subrotina"
     98: 1011000001101000;  -- jge.104 "Se não fez underflow, desvia para DEC_D0__RET"
     99: 1101000000000111;  -- ldaddr@7 [DEC_D5] "Define ponteiro para dig5"
    100: 0100111000000010;  -- ldi$2 %dx "Carrega 2 no %dx"
    101: 0001011000001001;  -- sta@9 %dx "Guarda na 2 no endereço do argumeto 1 de DEC_DX"
    102: 1011100000010010;  -- jsr.18 "Chama subrotina DEC_DX"
    103: 0001011100100101;  -- sta@293 %dx "Atualiza o HEX5 com o retorno subrotina"
    104: 1100000000000000;  -- ret.0 [DEC_D0__RET] "Retorna subrotina DEC_D0"
    399: 0001011000111111;  -- sta@63 %dx [INTR_TC1] "Guarda estado do %dx no endereço de recuperação de interrupção"
    400: 0000111101000010;  -- lda@322 %dx "Carrega SW9 no %dx"
    401: 0110111000000000;  -- ceqi$0 %dx "Compara se SW9 é FALSE"
    402: 1000100110011001;  -- jeq.409 "Se sim, Desvia para INTR_TC1__RETI"
    403: 0000111101000001;  -- lda@321 %dx "Se não, Carrega SW8 no %dx"
    404: 0110111000000001;  -- ceqi$1 %dx "Compara se SW8 é TRUE"
    405: 1000100110011000;  -- jeq.408 "Se sim, Pula para INTR_TC1__DEC"
    406: 1011100000011001;  -- jsr.25 [INTR_TC1__INC] "Se não, chama subrotina INC_D0"
    407: 1000000110011001;  -- jmp.409 "Desvia para INTR_TC1__RETI"
    408: 1011100001000001;  -- jsr.65 [INTR_TC1__DEC] "Chama subrotina DEC_D0"
    409: 0000111000111111;  -- lda@63 %dx [INTR_TC1__RETI] "Recupera estado do %dx do endereço de recuperação de interrupção"
    410: 1100100111111001;  -- reti%505 "Retorna da interrupção e reconhece estado de TC1"
    415: 0001011000111111;  -- sta@63 %dx [INTR_TC0] "Guarda estado do %dx no endereço de recuperação de interrupção"
    416: 0000111101000010;  -- lda@322 %dx "Carrega SW9 no %dx"
    417: 0110111000000001;  -- ceqi$1 %dx "Compara se SW9 é TRUE"
    418: 1000100110101001;  -- jeq.425 "Se sim, Desvia para INTR_TC0__RETI"
    419: 0000111101000001;  -- lda@321 %dx "Se não, Carrega SW8 no %dx"
    420: 0110111000000001;  -- ceqi$1 %dx "Compara se SW8 é TRUE"
    421: 1000100110101000;  -- jeq.424 "Se sim, Pula para INTR_TC0__DEC"
    422: 1011100000011001;  -- jsr.25 [INTR_TC0__INC] "Se não, chama subrotina INC_D0"
    423: 1000000110101001;  -- jmp.425 "Desvia para INTR_TC0__RETI"
    424: 1011100001000001;  -- jsr.65 [INTR_TC0__DEC] "Chama subrotina DEC_D0"
    425: 0000111000111111;  -- lda@63 %dx [INTR_TC0__RETI] "Recupera estado do %dx do endereço de recuperação de interrupção"
    426: 1100100111111010;  -- reti%506 "Retorna da interrupção e reconhece estado de TC0"
    431: 1100100111111011;  -- reti%507 [INTR_KEY4] "Retorna da interrupção e reconhece estado de KEY4"
    447: 0001011000111111;  -- sta@63 %dx [INTR_KEY3] "Guarda estado do %dx no endereço de recuperação de interrupção"
    448: 1011100001011001;  -- jsr.89 "Chama subrotina DEC_D4"
    449: 0000111000111111;  -- lda@63 %dx "Recupera estado do %dx do endereço de recuperação de interrupção"
    450: 1100100111111100;  -- reti%508 "Retorna da interrupção e reconhece estado de KEY3"
    463: 0001011000111111;  -- sta@63 %dx [INTR_KEY2] "Guarda estado do %dx no endereço de recuperação de interrupção"
    464: 1011100000110001;  -- jsr.49 "Chama subrotina INC_D4"
    465: 0000111000111111;  -- lda@63 %dx "Recupera estado do %dx do endereço de recuperação de interrupção"
    466: 1100100111111101;  -- reti%509 "Retorna da interrupção e reconhece estado de KEY2"
    479: 0001011000111111;  -- sta@63 %dx [INTR_KEY1] "Guarda estado do %dx no endereço de recuperação de interrupção"
    480: 1011100001001101;  -- jsr.77 "Chama subrotina DEC_D2"
    481: 0000111000111111;  -- lda@63 %dx "Recupera estado do %dx do endereço de recuperação de interrupção"
    482: 1100100111111110;  -- reti%510 "Retorna da interrupção e reconhece estado de KEY1"
    495: 0001011000111111;  -- sta@63 %dx [INTR_KEY0] "Guarda estado do %dx no endereço de recuperação de interrupção"
    496: 1011100000100101;  -- jsr.37 "Chama subrotina INC_D2"
    497: 0000111000111111;  -- lda@63 %dx "Recupera estado do %dx do endereço de recuperação de interrupção"
    498: 1100100111111111;  -- reti%511 "Retorna da interrupção e reconhece estado de KEY0"
END;
